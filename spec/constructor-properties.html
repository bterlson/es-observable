<emu-clause id="observable-prototype">
  <h1>Observable.prototype</h1>

  <p>The initial value of `Observable.prototype` is the intrinsic object %ObservablePrototype%.</p>

  <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
</emu-clause>

<emu-clause id="observable-from">
  <h1>Observable.from ( _x_ )</h1>

  <p>When the `from` method is called, the following steps are taken:</p>

  <emu-alg>
    1. Let _C_ be the *this* value.
    1. If IsConstructor(_C_) is *false*, let _C_ be %Observable%.
    1. Let _observableMethod_ be ? GetMethod(_x_, `@@observable`).
    1. If _observableMethod_ is not *undefined*, then
      1. Let _observable_ be ? Call(_observableMethod_, _x_, « »).
      1. If Type(_observable_) is not Object, throw a *TypeError* exception.
      1. Let _constructor_ be ? Get(_observable_, `"constructor"`).
      1. If SameValue(_constructor_, _C_) is *true*, return _observable_.
      1. Let _subscriber_ be a new built-in function object as defined in Observable.from Delegating Functions.
      1. Set _subscriber_.[[Observable]] to _observable_.
    1. Else,
      1. Let _iteratorMethod_ be ? GetMethod(_x_, `@@iterator`).
      1. If _iteratorMethod_ is *undefined*, throw a *TypeError* exception.
      1. Let _subscriber_ be a new built-in function object as defined in Observable.from Iteration Functions.
      1. Set _subscriber_.[[Iterable]] to _x_.
      1. Set _subscriber_.[[IteratorMethod]] to _iteratorMethod_.
    1. Return Construct(_C_, « ‍_subscriber_ »).
  </emu-alg>

  <emu-clause id="observable-from-delegating-functions">
    <h1>Observable.from Delegating Functions</h1>

    <p>An Observable.from delegating function is an anonymous built-in function that has an [[Observable]] internal slot.</p>

    <p>When an Observable.from delegating function is called with argument _observer_, the following steps are taken:</p>

    <emu-alg>
      1. Assert: _F_ has an [[Observable]] internal slot whose value is an Object.
      1. If Type(_observer_) is not Object, throw a *TypeError* exception.
      1. Let _observable_ be _F_.[[Observable]].
      1. Return Invoke(_observable_, `"subscribe"`, « ‍_observer_ »).
    </emu-alg>

    <p>The `length` property of an Observable.from delegating function is `1`.</p>
  </emu-clause>

  <emu-clause id="observable-from-iteration-functions">
    <h1>Observable.from Iteration Functions</h1>

    <p>An Observable.from iteration function is an anonymous built-in function that has [[Iterable]] and [[IteratorMethod]] internal slots.</p>

    <p>When an Observable.from iteration function is called with argument _observer_, the following steps are taken:</p>

    <emu-alg>
      1. Assert: _F_ has an [[Iterable]] internal slot whose value is an Object.
      1. Assert: _F_ has an [[IteratorMethod]] internal slot whose value is an Object.
      1. Assert: IsCallable(_F_.[[IteratorMethod]]) is *true*.
      1. If Type(_observer_) is not Object, throw a *TypeError* exception.
      1. Let _iterable_ be _F_.[[Iterable]].
      1. Let _iteratorMethod_ be _F_.[[IteratorMethod]].
      1. Let _iterator_ be ? GetIterator(_iterable_, ~sync~, _iteratorMethod_).
      1. Repeat
        1. Let _closed_ be ? ToBoolean(? GetV(_observer_, `"closed"`)).
        1. If _closed_ is *true*, then
          1. Perform ? IteratorClose(_iterator_, *undefined*).
          1. Return *undefined*.
        1. Let _next_ be ? IteratorStep(_iterator_).
        1. If _next_ is *false*, then
          1. Perform ? Invoke(_observer_, `"complete"`, « »).
          1. Return *undefined*.
        1. Let _nextValue_ be ? IteratorValue(_next_).
        1. Perform ? Invoke(_observer_, `"next"`, « ‍_nextValue_ »).
    </emu-alg>

    <p>The `length` property of an Observable.from iteration function is `1`.</p>
  </emu-clause>

</emu-clause>

<emu-clause id="observable-of">
  <h1>Observable.of ( ..._items_ )</h1>

  <emu-alg>
    1. Let _C_ be the *this* value.
    1. If IsConstructor(_C_) is *false*, let _C_ be %Observable%.
    1. Let _subscriber_ be a new built-in function object as defined in Observable.of Subscriber Functions.
    1. Let _items_ be the List of arguments passed to this function.
    1. Set _subscriber_.[[Items]] to _items_.
    1. Return Construct(_C_, « ‍_subscriber_ »).
  </emu-alg>

  <emu-clause id="observable-of-subscriber-functions">
    <h1>Observable.of Subscriber Functions</h1>

    <p>An Observable.of subscriber function is an anonymous built-in function that has an [[Items]] internal slot.</p>

    <p>When an Observable.of subscriber function is called with argument _observer_, the following steps are taken:</p>

    <emu-alg>
      1. Assert: _F_ has an [[Items]] internal slot whose value is a List.
      1. If Type(_observer_) is not Object, throw a *TypeError* exception.
      1. Let _items_ be _F_.[[Items]].
      1. For each element _value_ of _items_
        1. Let _closed_ be ? ToBoolean(? GetV(_observer_, `"closed"`)).
        1. If _closed_ is *true*, then return *undefined*.
        1. Perform ? Invoke(_observer_, `"next"`, « ‍_value_ »).
      1. Let _closed_ be ? ToBoolean(? GetV(_observer_, `"closed"`)).
      1. If _closed_ is *true*, then return *undefined*.
      1. Perform ? Invoke(_observer_, `"complete"`, « »).
      1. Return *undefined*.
    </emu-alg>

    <p>The `length` property of an Observable.of subscriber function is `1`.</p>
  </emu-clause>

</emu-clause>
